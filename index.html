<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D Room Planner with Export</title>
    <style>
        :root {
            --primary-color: #3b82f6;
            --bg-color: transparent;
            --panel-bg: rgba(255, 255, 255, 0.25);
            --border-color: rgba(255, 255, 255, 0.3);
            --handle-size: 10px;
            --text-color: #1f2937;
        }

        body {
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            height: 100vh;
            display: flex;
            background-color: #f3f4f6;
            color: var(--text-color);
            overflow: hidden;
        }

        /* --- Sidebar Controls --- */
        #sidebar {
            width: 300px;
            background: #ffffff;
            border-right: 1px solid #f3f4f6;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            z-index: 10;
            overflow-y: auto;
        }

        h2, h3 { margin: 0 0 10px 0; color: var(--text-color); font-weight: 600; letter-spacing: -0.02em; text-shadow: none; }
        
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding-bottom: 20px;
            border-bottom: 1px solid #f3f4f6;
        }

        label { font-size: 0.85rem; font-weight: 600; color: #555; }
        
        input, select {
            padding: 10px;
            background: #ffffff;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            font-size: 14px;
            transition: border-color 0.2s;
        }

        input:focus, select:focus {
            outline: none;
            border-color: var(--primary-color);
        }

        input[type="checkbox"] {
            width: auto;
            margin-right: 8px;
            accent-color: var(--primary-color);
        }

        .unit-display {
            font-size: 0.75rem;
            color: #9ca3af;
            margin-top: -5px;
        }

        button {
            padding: 10px;
            background: #18181b;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            font-size: 14px;
            transition: background 0.2s;
        }

        button:hover {
            background: #27272a;
        }

        button:active {
            transform: none;
        }
        
        button.secondary-btn {
            background: #ffffff;
            color: #374151;
            border: 1px solid #e5e7eb;
        }
        button.secondary-btn:hover { background: #f9fafb; border-color: #d1d5db; }

        button.delete-btn {
            background: #ef4444;
            margin-top: auto; 
        }
        button.delete-btn:hover {
            background: #dc2626;
        }
        
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
            background: rgba(0,0,0,0.1);
            color: rgba(0,0,0,0.3);
        }

        .row { display: flex; gap: 10px; align-items: center;}
        .row > * { flex: 1; }

        /* --- Workspace Area --- */
        #workspace {
            flex: 1;
            position: relative;
            overflow: auto;
            display: flex;
            align-items: center;
            justify-content: center;
            background-image: radial-gradient(rgba(255,255,255,0.2) 1px, transparent 1px);
            transition: background-size 0.3s; 
        }

        /* --- The Room --- */
        #room {
            background: #ffffff;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            position: relative;
            box-shadow: 0 10px 30px rgba(0,0,0,0.05);
            transition: width 0.3s, height 0.3s;
        }

        /* --- Furniture Items --- */
        .furniture {
            position: absolute;
            cursor: move; /* Fallback */
            cursor: grab;
            box-sizing: border-box;
            user-select: none;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            color: rgba(255,255,255,0.9);
            border: 1px solid rgba(0,0,0,0.1);
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            border-radius: 6px;
            /* Transform Origin center for rotation */
            transform-origin: center center;
        }

        .furniture:active { cursor: grabbing; }

        .furniture.selected {
            outline: 2px dashed #ff00d4;
            outline-offset: 2px;
            z-index: 100;
        }

        /* --- Resize Handles --- */
        .resize-handle {
            position: absolute;
            width: var(--handle-size);
            height: var(--handle-size);
            background-color: white;
            border: 1px solid var(--primary-color);
            z-index: 101;
            display: none;
        }
        
        .furniture.selected .resize-handle { display: block; }

        /* Handle Positions */
        .handle-nw { top: -6px; left: -6px; cursor: nw-resize; }
        .handle-n  { top: -6px; left: 50%; transform: translateX(-50%); cursor: n-resize; }
        .handle-ne { top: -6px; right: -6px; cursor: ne-resize; }
        .handle-e  { top: 50%; right: -6px; transform: translateY(-50%); cursor: e-resize; }
        .handle-se { bottom: -6px; right: -6px; cursor: se-resize; }
        .handle-s  { bottom: -6px; left: 50%; transform: translateX(-50%); cursor: s-resize; }
        .handle-sw { bottom: -6px; left: -6px; cursor: sw-resize; }
        .handle-w  { top: 50%; left: -6px; transform: translateY(-50%); cursor: w-resize; }

        /* --- Rotation Handle --- */
        .rotate-handle {
            position: absolute;
            width: 12px;
            height: 12px;
            background-color: #ff00d4; /* Distinct color */
            border-radius: 50%;
            top: -25px;
            left: 50%;
            transform: translateX(-50%);
            cursor: grab;
            z-index: 102;
            display: none;
        }
        
        /* The stick connecting to the box */
        .rotate-handle::after {
            content: '';
            position: absolute;
            top: 12px; /* bottom of circle */
            left: 50%;
            width: 1px;
            height: 15px;
            background-color: #ff00d4;
            transform: translateX(-50%);
        }

        .furniture.selected .rotate-handle { display: block; }

        .hidden { display: none !important; }
        
        /* File Input hidden */
        #fileInput { display: none; }

    </style>
</head>
<body>

    <!-- Sidebar Controls -->
    <aside id="sidebar">
        <h2>Room Planner</h2>

        <!-- Room Settings -->
        <div class="control-group">
            <h3>Room Settings</h3>

            <!-- Size -->
            <label>Dimensions (px)</label>
            <div class="row">
                <input type="number" id="roomWidth" value="600" min="200" max="2000" title="Width">
                <input type="number" id="roomHeight" value="400" min="200" max="2000" title="Height">
            </div>
            <span id="roomUnitsDisplay" class="unit-display">Room is approx 12 x 8 units</span>

            <!-- Unit -->
            <div style="margin-top: 5px;">
                <label>Grid Unit (px)</label>
                <input type="number" id="unitSize" value="50" min="10" max="200" style="width: 100%; box-sizing: border-box;">
            </div>

            <!-- Snapping -->
            <div class="row" style="margin-top: 5px; align-items: center;">
                <input type="checkbox" id="snapEnabled" checked style="width: auto;">
                <label for="snapEnabled" style="flex: 2; margin: 0;">Snap to Grid</label>
                <input type="number" id="snapStep" value="0.5" step="0.1" min="0.1" style="flex: 1;">
            </div>
        </div>

        <!-- Furniture Controls -->
        <div class="control-group">
            <h3>Furniture</h3>

            <!-- Add New -->
            <div style="padding: 0; margin-bottom: 15px;">
                <h4 style="margin: 0 0 10px 0; font-size: 0.85rem; text-transform: uppercase; color: #9ca3af; letter-spacing: 0.05em;">Add New</h4>

                <label>Shape</label>
                <select id="itemShape" style="width: 100%; margin-bottom: 8px;">
                    <option value="rectangle">Rectangle</option>
                    <option value="circle">Circle</option>
                </select>

                <div id="rectInputs" class="row" style="margin-bottom: 8px;">
                    <input type="number" id="itemWidth" value="2" step="0.5" placeholder="W">
                    <input type="number" id="itemHeight" value="1" step="0.5" placeholder="H">
                </div>

                <div id="circleInputs" class="hidden" style="margin-bottom: 8px;">
                    <input type="number" id="itemRadius" value="1" step="0.5" placeholder="Radius" style="width: 100%;">
                </div>

                <label>Color</label>
                <input type="color" id="itemColor" value="#3b82f6" style="height: 30px; width: 100%; border: none; padding: 0;">

                <button id="addBtn" style="width: 100%; margin-top: 8px;">Spawn Item</button>
            </div>

            <!-- Edit Selected -->
            <div style="padding: 0;">
                <h4 style="margin: 0 0 10px 0; font-size: 0.85rem; text-transform: uppercase; color: #9ca3af; letter-spacing: 0.05em;">Edit Selected</h4>

                <div class="row" style="margin-bottom: 8px;">
                    <div>
                        <label style="font-size: 0.75rem;">W / Rad (px)</label>
                        <input type="number" id="editItemWidth" disabled>
                    </div>
                    <div>
                        <label style="font-size: 0.75rem;">H (px)</label>
                        <input type="number" id="editItemHeight" disabled>
                    </div>
                </div>

                <div class="row" style="margin-bottom: 8px;">
                     <div>
                        <label style="font-size: 0.75rem;">Color</label>
                        <input type="color" id="editItemColor" style="height: 30px; width: 100%; padding: 0; border: none;" disabled>
                     </div>
                     <div>
                        <label style="font-size: 0.75rem;">Rotation (Â°)</label>
                        <input type="number" id="itemRotationInput" value="0" step="15" disabled>
                     </div>
                </div>

                <button id="deleteBtn" class="delete-btn" style="width: 100%;" disabled>Delete</button>
            </div>

            <div style="font-size: 0.75rem; color: #666; margin-top: 10px; line-height: 1.3;">
                Click to select. Drag to move. Use handles to resize/rotate.
            </div>
        </div>

        <!-- Data -->
        <div class="control-group" style="border-bottom: none;">
            <h3>Data</h3>
            <div class="row">
                <button id="exportBtn" class="secondary-btn">Export</button>
                <button id="importBtn" class="secondary-btn">Import</button>
                <input type="file" id="fileInput" accept=".json">
            </div>
        </div>

    </aside>

    <!-- Main Workspace -->
    <main id="workspace">
        <div id="room" style="width: 600px; height: 400px;">
            <!-- Furniture items will be injected here -->
        </div>
    </main>

    <script>
        /* --- State & Elements --- */
        const room = document.getElementById('room');
        const workspace = document.getElementById('workspace');
        
        // Inputs
        const unitSizeInput = document.getElementById('unitSize');
        const roomWInput = document.getElementById('roomWidth');
        const roomHInput = document.getElementById('roomHeight');
        const roomUnitsDisplay = document.getElementById('roomUnitsDisplay');
        const snapEnabledInput = document.getElementById('snapEnabled');
        const snapStepInput = document.getElementById('snapStep');
        
        const shapeSelect = document.getElementById('itemShape');
        const rectInputs = document.getElementById('rectInputs');
        const circleInputs = document.getElementById('circleInputs');
        const itemWInput = document.getElementById('itemWidth');
        const itemHInput = document.getElementById('itemHeight');
        const itemRadiusInput = document.getElementById('itemRadius');
        const itemColorInput = document.getElementById('itemColor');
        
        const itemRotationInput = document.getElementById('itemRotationInput');
        
        // Edit Inputs
        const editItemWidthInput = document.getElementById('editItemWidth');
        const editItemHeightInput = document.getElementById('editItemHeight');
        const editItemColorInput = document.getElementById('editItemColor');

        // Buttons
        const addBtn = document.getElementById('addBtn');
        const deleteBtn = document.getElementById('deleteBtn');
        const exportBtn = document.getElementById('exportBtn');
        const importBtn = document.getElementById('importBtn');
        const fileInput = document.getElementById('fileInput');

        let selectedItem = null;
        let isDragging = false;
        let isResizing = false;
        let isRotating = false;
        
        // State for dragging
        let dragOffsetX = 0;
        let dragOffsetY = 0;

        // State for resizing
        let resizeDirection = '';
        let initialResizeRect = {};
        let initialMousePos = {};
        let initialRotation = 0;

        // State for rotating
        let rotateCenter = {x:0, y:0};
        let initialAngle = 0;

        /* --- Initialization --- */
        function init() {
            updateGrid();
            updateRoomSize();
        }

        /* --- Unit / Grid Logic --- */
        function updateGrid() {
            const unit = parseInt(unitSizeInput.value) || 50;
            workspace.style.backgroundSize = `${unit}px ${unit}px`;
            updateRoomDisplayText();
        }

        unitSizeInput.addEventListener('input', updateGrid);

        /* --- Room Resizing Logic --- */
        function updateRoomSize() {
            let w = parseInt(roomWInput.value) || 600;
            let h = parseInt(roomHInput.value) || 400;
            
            if(w < 100) w = 100;
            if(h < 100) h = 100;

            room.style.width = w + 'px';
            room.style.height = h + 'px';
            
            updateRoomDisplayText();
            
            const items = document.querySelectorAll('.furniture');
            items.forEach(item => constrainItem(item));
        }

        function updateRoomDisplayText() {
            const w = parseInt(room.style.width);
            const h = parseInt(room.style.height);
            const unit = parseInt(unitSizeInput.value) || 50;
            
            const wUnits = (w / unit).toFixed(1);
            const hUnits = (h / unit).toFixed(1);
            
            roomUnitsDisplay.textContent = `Room is approx ${wUnits} x ${hUnits} units`;
        }

        roomWInput.addEventListener('input', updateRoomSize);
        roomHInput.addEventListener('input', updateRoomSize);

        /* --- UI Toggle for Inputs --- */
        shapeSelect.addEventListener('change', (e) => {
            if (e.target.value === 'rectangle') {
                rectInputs.classList.remove('hidden');
                circleInputs.classList.add('hidden');
            } else {
                rectInputs.classList.add('hidden');
                circleInputs.classList.remove('hidden');
            }
        });

        /* --- Snapping Helper --- */
        function snapValue(val) {
            if (!snapEnabledInput.checked) return val;
            
            const unit = parseInt(unitSizeInput.value) || 50;
            const stepUnits = parseFloat(snapStepInput.value) || 0.5;
            const snapPixels = unit * stepUnits;
            
            return Math.round(val / snapPixels) * snapPixels;
        }

        /* --- Helper: Get Rotation from Element --- */
        function getRotation(el) {
            return parseFloat(el.dataset.rotation) || 0;
        }

        function setRotation(el, deg) {
            el.dataset.rotation = deg;
            el.style.transform = `rotate(${deg}deg)`;
            if(el === selectedItem) {
                itemRotationInput.value = Math.round(deg % 360);
            }
        }

        /* --- Sidebar Rotation Input --- */
        itemRotationInput.addEventListener('change', () => {
            if (selectedItem) {
                setRotation(selectedItem, parseFloat(itemRotationInput.value));
            }
        });

        /* --- Edit Selected Item Inputs --- */
        function updateEditInputs() {
            if (!selectedItem) return;

            editItemWidthInput.value = parseFloat(selectedItem.style.width);
            editItemHeightInput.value = parseFloat(selectedItem.style.height);

            // Convert rgb to hex for color input
            const rgb = selectedItem.style.backgroundColor;
            editItemColorInput.value = rgbToHex(rgb);
        }

        // Helper to convert rgb(x, y, z) to #rrggbb
        function rgbToHex(rgb) {
            if (!rgb) return '#ffffff';
            if (rgb.startsWith('#')) return rgb;

            const match = rgb.match(/\d+/g);
            if (!match) return '#ffffff';

            const r = parseInt(match[0]);
            const g = parseInt(match[1]);
            const b = parseInt(match[2]);

            return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
        }

        editItemWidthInput.addEventListener('change', () => {
            if (selectedItem) {
                let val = parseFloat(editItemWidthInput.value);
                if (val < 10) val = 10;
                val = snapValue(val);

                selectedItem.style.width = val + 'px';

                if (selectedItem.dataset.shape === 'circle') {
                    selectedItem.style.height = val + 'px'; // Keep circle aspect
                    editItemHeightInput.value = val;
                }

                constrainItem(selectedItem); // Ensure still in bounds
            }
        });

        editItemHeightInput.addEventListener('change', () => {
            if (selectedItem) {
                let val = parseFloat(editItemHeightInput.value);
                if (val < 10) val = 10;
                val = snapValue(val);

                selectedItem.style.height = val + 'px';

                if (selectedItem.dataset.shape === 'circle') {
                    selectedItem.style.width = val + 'px'; // Keep circle aspect
                    editItemWidthInput.value = val;
                }

                constrainItem(selectedItem);
            }
        });

        editItemColorInput.addEventListener('input', () => {
             if (selectedItem) {
                 selectedItem.style.backgroundColor = editItemColorInput.value;
             }
        });

        /* --- Factory Function --- */
        // Creates a DOM element from config properties (in pixels)
        function createFurnitureElement(config) {
            const el = document.createElement('div');
            el.classList.add('furniture');
            
            // Set basic props
            el.style.width = config.width + 'px';
            el.style.height = config.height + 'px';
            el.style.left = config.left + 'px';
            el.style.top = config.top + 'px';
            el.style.backgroundColor = config.color;
            
            // Shape specific
            el.dataset.shape = config.shape;
            if (config.shape === 'circle') {
                el.style.borderRadius = '50%';
            } else {
                el.style.borderRadius = '4px';
            }

            // Rotation
            setRotation(el, config.rotation || 0);

            // 1. Resize Handles
            const directions = ['nw', 'n', 'ne', 'e', 'se', 's', 'sw', 'w'];
            directions.forEach(dir => {
                const handle = document.createElement('div');
                handle.className = `resize-handle handle-${dir}`;
                handle.dataset.dir = dir;
                handle.addEventListener('mousedown', onResizeStart);
                el.appendChild(handle);
            });

            // 2. Rotation Handle
            const rotHandle = document.createElement('div');
            rotHandle.className = 'rotate-handle';
            rotHandle.addEventListener('mousedown', onRotateStart);
            el.appendChild(rotHandle);

            // Drag Events
            el.addEventListener('mousedown', onDragStart);

            return el;
        }

        /* --- Spawn Logic (From UI) --- */
        addBtn.addEventListener('click', () => {
            const shape = shapeSelect.value;
            const color = itemColorInput.value;
            const unitSize = parseInt(unitSizeInput.value) || 50;
            
            let wPixels, hPixels;

            if (shape === 'rectangle') {
                const wUnits = parseFloat(itemWInput.value) || 1;
                const hUnits = parseFloat(itemHInput.value) || 1;
                wPixels = wUnits * unitSize;
                hPixels = hUnits * unitSize;
            } else {
                const rUnits = parseFloat(itemRadiusInput.value) || 0.5;
                const dPixels = (rUnits * 2) * unitSize;
                wPixels = dPixels;
                hPixels = dPixels;
            }

            // Center in room
            const roomW = parseInt(room.style.width);
            const roomH = parseInt(room.style.height);
            const left = (roomW / 2 - wPixels / 2);
            const top = (roomH / 2 - hPixels / 2);

            const config = {
                shape: shape,
                color: color,
                width: wPixels,
                height: hPixels,
                left: left,
                top: top,
                rotation: 0
            };

            const el = createFurnitureElement(config);
            room.appendChild(el);
            selectItem(el);
        });

        /* --- Export Logic --- */
        exportBtn.addEventListener('click', () => {
            // Gather state
            const items = [];
            document.querySelectorAll('.furniture').forEach(el => {
                items.push({
                    shape: el.dataset.shape || 'rectangle',
                    color: el.style.backgroundColor, // rgb or hex
                    width: parseFloat(el.style.width),
                    height: parseFloat(el.style.height),
                    left: parseFloat(el.style.left),
                    top: parseFloat(el.style.top),
                    rotation: getRotation(el)
                });
            });

            const data = {
                room: {
                    width: parseInt(room.style.width),
                    height: parseInt(room.style.height),
                    unitSize: parseInt(unitSizeInput.value)
                },
                items: items
            };

            const jsonStr = JSON.stringify(data, null, 2);
            const blob = new Blob([jsonStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = 'room_plan.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        });

        /* --- Import Logic --- */
        importBtn.addEventListener('click', () => {
            fileInput.click();
        });

        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    const data = JSON.parse(event.target.result);
                    loadData(data);
                } catch (err) {
                    alert('Error parsing JSON file: ' + err.message);
                }
                // Reset input so same file can be selected again
                fileInput.value = '';
            };
            reader.readAsText(file);
        });

        function loadData(data) {
            // 1. Restore Room Settings
            if (data.room) {
                roomWInput.value = data.room.width || 600;
                roomHInput.value = data.room.height || 400;
                unitSizeInput.value = data.room.unitSize || 50;
                
                // Trigger updates
                updateGrid();
                updateRoomSize();
            }

            // 2. Clear existing Items
            room.innerHTML = '';
            selectItem(null);

            // 3. Create Items
            if (data.items && Array.isArray(data.items)) {
                data.items.forEach(itemConfig => {
                    const el = createFurnitureElement(itemConfig);
                    room.appendChild(el);
                });
            }
        }

        /* --- Selection Logic --- */
        function selectItem(item) {
            if (selectedItem) {
                selectedItem.classList.remove('selected');
            }
            selectedItem = item;
            if (selectedItem) {
                selectedItem.classList.add('selected');
                deleteBtn.disabled = false;

                // Enable inputs
                itemRotationInput.disabled = false;
                editItemWidthInput.disabled = false;
                editItemHeightInput.disabled = false;
                editItemColorInput.disabled = false;

                // Populate values
                itemRotationInput.value = Math.round(getRotation(selectedItem) % 360);
                updateEditInputs();
            } else {
                deleteBtn.disabled = true;

                // Disable inputs
                itemRotationInput.disabled = true;
                itemRotationInput.value = 0;

                editItemWidthInput.disabled = true;
                editItemWidthInput.value = '';
                editItemHeightInput.disabled = true;
                editItemHeightInput.value = '';
                editItemColorInput.disabled = true;
            }
        }

        room.addEventListener('mousedown', (e) => {
            if (e.target === room) {
                selectItem(null);
            }
        });

        /* --- Deletion Logic --- */
        function deleteSelected() {
            if (selectedItem) {
                selectedItem.remove();
                selectItem(null);
            }
        }

        deleteBtn.addEventListener('click', deleteSelected);

        window.addEventListener('keydown', (e) => {
            if (e.key === 'Delete' || e.key === 'Backspace') {
                if (document.activeElement.tagName === 'INPUT') return;
                deleteSelected();
            }
        });

        /* --- Dragging Logic --- */
        function onDragStart(e) {
            // Ignore if clicked on a handle
            if (e.target.classList.contains('resize-handle') || e.target.classList.contains('rotate-handle')) return;

            e.stopPropagation();
            const target = e.currentTarget;
            selectItem(target);

            isDragging = true;
            
            const rect = target.getBoundingClientRect();
            const roomRect = room.getBoundingClientRect();
            
            const cssLeft = parseFloat(target.style.left) || 0;
            const cssTop = parseFloat(target.style.top) || 0;
            
            const mouseX = e.clientX - roomRect.left;
            const mouseY = e.clientY - roomRect.top;
            
            dragOffsetX = mouseX - cssLeft;
            dragOffsetY = mouseY - cssTop;

            window.addEventListener('mousemove', onDragMove);
            window.addEventListener('mouseup', onDragEnd);
        }

        function onDragMove(e) {
            if (!isDragging || !selectedItem) return;

            const roomRect = room.getBoundingClientRect();
            const mouseX = e.clientX - roomRect.left;
            const mouseY = e.clientY - roomRect.top;
            
            let newLeft = mouseX - dragOffsetX;
            let newTop = mouseY - dragOffsetY;

            // Apply Snap
            newLeft = snapValue(newLeft);
            newTop = snapValue(newTop);

            // Constraint (using unrotated box for simplicity and stability)
            const constrained = getConstrainedPosition(selectedItem, newLeft, newTop);

            selectedItem.style.left = constrained.x + 'px';
            selectedItem.style.top = constrained.y + 'px';
        }

        function onDragEnd() {
            isDragging = false;
            window.removeEventListener('mousemove', onDragMove);
            window.removeEventListener('mouseup', onDragEnd);
        }

        /* --- Rotation Logic --- */
        function onRotateStart(e) {
            e.stopPropagation();
            isRotating = true;
            
            const rect = selectedItem.getBoundingClientRect();
            // Center of the element in screen coordinates
            rotateCenter = {
                x: rect.left + rect.width / 2,
                y: rect.top + rect.height / 2
            };
            
            const dx = e.clientX - rotateCenter.x;
            const dy = e.clientY - rotateCenter.y;
            
            initialAngle = Math.atan2(dy, dx) * (180 / Math.PI);
            initialRotation = getRotation(selectedItem);

            window.addEventListener('mousemove', onRotateMove);
            window.addEventListener('mouseup', onRotateEnd);
        }

        function onRotateMove(e) {
            if (!isRotating || !selectedItem) return;

            const dx = e.clientX - rotateCenter.x;
            const dy = e.clientY - rotateCenter.y;
            const currentAngle = Math.atan2(dy, dx) * (180 / Math.PI);
            
            let delta = currentAngle - initialAngle;
            let newRot = initialRotation + delta;

            if (snapEnabledInput.checked) {
                newRot = Math.round(newRot / 15) * 15;
            }

            setRotation(selectedItem, newRot);
        }

        function onRotateEnd() {
            isRotating = false;
            window.removeEventListener('mousemove', onRotateMove);
            window.removeEventListener('mouseup', onRotateEnd);
        }

        /* --- Resize Logic --- */
        function onResizeStart(e) {
            e.stopPropagation();
            isResizing = true;
            resizeDirection = e.target.dataset.dir;
            initialRotation = getRotation(selectedItem);
            
            // We need the CSS width/height/left/top
            initialResizeRect = {
                width: parseFloat(selectedItem.style.width),
                height: parseFloat(selectedItem.style.height),
                left: parseFloat(selectedItem.style.left),
                top: parseFloat(selectedItem.style.top)
            };

            initialMousePos = { x: e.clientX, y: e.clientY };

            window.addEventListener('mousemove', onResizeMove);
            window.addEventListener('mouseup', onResizeEnd);
        }

        function onResizeMove(e) {
            if (!isResizing || !selectedItem) return;

            const rawDx = e.clientX - initialMousePos.x;
            const rawDy = e.clientY - initialMousePos.y;

            const rad = initialRotation * (Math.PI / 180);
            const cos = Math.cos(rad);
            const sin = Math.sin(rad);

            const localDx = rawDx * cos + rawDy * sin;
            const localDy = rawDy * cos - rawDx * sin;

            let newW = initialResizeRect.width;
            let newH = initialResizeRect.height;
            
            if (resizeDirection.includes('e')) newW += localDx;
            if (resizeDirection.includes('w')) newW -= localDx;
            if (resizeDirection.includes('s')) newH += localDy;
            if (resizeDirection.includes('n')) newH -= localDy;

            newW = snapValue(newW);
            newH = snapValue(newH);

            if (newW < 20) newW = 20;
            if (newH < 20) newH = 20;

            selectedItem.style.width = newW + 'px';
            selectedItem.style.height = newH + 'px';

            // Update sidebar inputs live
            updateEditInputs();
        }

        function onResizeEnd() {
            isResizing = false;
            window.removeEventListener('mousemove', onResizeMove);
            window.removeEventListener('mouseup', onResizeEnd);
        }

        /* --- Boundary Constraint Helper --- */
        function getConstrainedPosition(el, left, top) {
            const elW = parseFloat(el.style.width); // Use CSS width
            const elH = parseFloat(el.style.height);
            const roomW = parseInt(room.style.width);
            const roomH = parseInt(room.style.height);
            const rotation = getRotation(el);

            if (rotation === 0) {
                // Optimization for 0 rotation
                if (left < 0) left = 0;
                if (top < 0) top = 0;
                if (left + elW > roomW) left = roomW - elW;
                if (top + elH > roomH) top = roomH - elH;
                return { x: left, y: top };
            }

            // Calculate min/max offsets relative to center
            const rad = rotation * (Math.PI / 180);
            const cos = Math.cos(rad);
            const sin = Math.sin(rad);

            const hw = elW / 2;
            const hh = elH / 2;

            // 4 corners relative to center (before rotation)
            const corners = [
                {x: -hw, y: -hh},
                {x: hw, y: -hh},
                {x: hw, y: hh},
                {x: -hw, y: hh}
            ];

            let minOffX = Infinity, maxOffX = -Infinity;
            let minOffY = Infinity, maxOffY = -Infinity;

            corners.forEach(p => {
                const rx = p.x * cos - p.y * sin;
                const ry = p.x * sin + p.y * cos;
                if (rx < minOffX) minOffX = rx;
                if (rx > maxOffX) maxOffX = rx;
                if (ry < minOffY) minOffY = ry;
                if (ry > maxOffY) maxOffY = ry;
            });

            // Allowed range for 'left' (which is center - hw) and 'top' (center - hh)
            // left >= -hw - minOffX
            // left <= roomW - hw - maxOffX
            const minLeft = -hw - minOffX;
            const maxLeft = roomW - hw - maxOffX;

            const minTop = -hh - minOffY;
            const maxTop = roomH - hh - maxOffY;

            if (left < minLeft) left = minLeft;
            if (left > maxLeft) left = maxLeft;

            if (top < minTop) top = minTop;
            if (top > maxTop) top = maxTop;

            return { x: left, y: top };
        }

        function constrainItem(el) {
            const currentLeft = parseFloat(el.style.left) || 0;
            const currentTop = parseFloat(el.style.top) || 0;
            const pos = getConstrainedPosition(el, currentLeft, currentTop);
            el.style.left = pos.x + 'px';
            el.style.top = pos.y + 'px';
        }

        // Initialize on load
        init();

    </script>
</body>
</html>
