<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D Room Planner with Units</title>
    <style>
        :root {
            --primary-color: #3b82f6;
            --bg-color: #f3f4f6;
            --panel-bg: #ffffff;
            --border-color: #d1d5db;
            --handle-size: 10px;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            height: 100vh;
            display: flex;
            background-color: var(--bg-color);
            overflow: hidden;
        }

        /* --- Sidebar Controls --- */
        #sidebar {
            width: 300px;
            background: var(--panel-bg);
            border-right: 1px solid var(--border-color);
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            box-shadow: 2px 0 5px rgba(0,0,0,0.05);
            z-index: 10;
            overflow-y: auto;
        }

        h2, h3 { margin: 0 0 10px 0; color: #333; }
        
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding-bottom: 15px;
            border-bottom: 1px solid #eee;
        }

        label { font-size: 0.85rem; font-weight: 600; color: #555; }
        
        input, select {
            padding: 8px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 14px;
        }

        input[type="checkbox"] {
            width: auto;
            margin-right: 8px;
        }

        .unit-display {
            font-size: 0.75rem;
            color: #666;
            margin-top: -5px;
            font-style: italic;
        }

        button {
            padding: 10px;
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 600;
            transition: background 0.2s;
        }

        button:hover { background-color: #2563eb; }
        
        button.delete-btn {
            background-color: #ef4444;
            margin-top: auto; 
        }
        button.delete-btn:hover { background-color: #dc2626; }
        
        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }

        .row { display: flex; gap: 10px; align-items: center;}
        .row > * { flex: 1; }

        /* --- Workspace Area --- */
        #workspace {
            flex: 1;
            position: relative;
            overflow: auto;
            display: flex;
            align-items: center;
            justify-content: center;
            background-image: radial-gradient(#aaa 1px, transparent 1px);
            transition: background-size 0.3s; 
        }

        /* --- The Room --- */
        #room {
            background-color: white;
            border: 4px solid #333;
            position: relative;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
            transition: width 0.3s, height 0.3s;
        }

        /* --- Furniture Items --- */
        .furniture {
            position: absolute;
            cursor: move; /* Fallback */
            cursor: grab;
            box-sizing: border-box;
            user-select: none;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            color: rgba(255,255,255,0.7);
            border: 1px solid rgba(0,0,0,0.1);
            /* Transform Origin center for rotation */
            transform-origin: center center;
        }

        .furniture:active { cursor: grabbing; }

        .furniture.selected {
            outline: 2px dashed #ff00d4;
            outline-offset: 2px;
            z-index: 100;
        }

        /* --- Resize Handles --- */
        .resize-handle {
            position: absolute;
            width: var(--handle-size);
            height: var(--handle-size);
            background-color: white;
            border: 1px solid var(--primary-color);
            z-index: 101;
            display: none;
        }
        
        .furniture.selected .resize-handle { display: block; }

        /* Handle Positions */
        .handle-nw { top: -6px; left: -6px; cursor: nw-resize; }
        .handle-n  { top: -6px; left: 50%; transform: translateX(-50%); cursor: n-resize; }
        .handle-ne { top: -6px; right: -6px; cursor: ne-resize; }
        .handle-e  { top: 50%; right: -6px; transform: translateY(-50%); cursor: e-resize; }
        .handle-se { bottom: -6px; right: -6px; cursor: se-resize; }
        .handle-s  { bottom: -6px; left: 50%; transform: translateX(-50%); cursor: s-resize; }
        .handle-sw { bottom: -6px; left: -6px; cursor: sw-resize; }
        .handle-w  { top: 50%; left: -6px; transform: translateY(-50%); cursor: w-resize; }

        /* --- Rotation Handle --- */
        .rotate-handle {
            position: absolute;
            width: 12px;
            height: 12px;
            background-color: #ff00d4; /* Distinct color */
            border-radius: 50%;
            top: -25px;
            left: 50%;
            transform: translateX(-50%);
            cursor: grab;
            z-index: 102;
            display: none;
        }
        
        /* The stick connecting to the box */
        .rotate-handle::after {
            content: '';
            position: absolute;
            top: 12px; /* bottom of circle */
            left: 50%;
            width: 1px;
            height: 15px;
            background-color: #ff00d4;
            transform: translateX(-50%);
        }

        .furniture.selected .rotate-handle { display: block; }

        .hidden { display: none !important; }

    </style>
</head>
<body>

    <!-- Sidebar Controls -->
    <aside id="sidebar">
        <h2>Room Planner</h2>

        <!-- Unit Definition -->
        <div class="control-group" style="background-color: #eef2ff; padding: 10px; border-radius: 6px; border-bottom: none;">
            <h3>1. Define Unit</h3>
            <label>1 Unit equals (pixels):</label>
            <input type="number" id="unitSize" value="50" min="10" max="200">
            <span class="unit-display">Grid updates to match this size.</span>
        </div>

        <!-- Room Dimensions -->
        <div class="control-group">
            <h3>2. Room Size</h3>
            <div class="row">
                <div>
                    <label>Width (px)</label>
                    <input type="number" id="roomWidth" value="600" min="200" max="2000">
                </div>
                <div>
                    <label>Height (px)</label>
                    <input type="number" id="roomHeight" value="400" min="200" max="2000">
                </div>
            </div>
            <span id="roomUnitsDisplay" class="unit-display">Room is approx 12 x 8 units</span>
        </div>

         <!-- Snapping Controls -->
         <div class="control-group">
            <h3>3. Snapping</h3>
            <div class="row" style="justify-content: flex-start;">
                <input type="checkbox" id="snapEnabled" checked>
                <label for="snapEnabled" style="margin: 0; cursor: pointer;">Snap to Grid</label>
            </div>
            <label>Snap Step (Units)</label>
            <input type="number" id="snapStep" value="0.5" step="0.1" min="0.1">
        </div>

        <!-- Furniture Creator -->
        <div class="control-group">
            <h3>4. Add Furniture</h3>
            
            <label>Shape</label>
            <select id="itemShape">
                <option value="rectangle">Rectangle</option>
                <option value="circle">Circle</option>
            </select>

            <!-- Inputs for Rectangle -->
            <div id="rectInputs" class="row">
                <div>
                    <label>W (Units)</label>
                    <input type="number" id="itemWidth" value="2" step="0.5">
                </div>
                <div>
                    <label>H (Units)</label>
                    <input type="number" id="itemHeight" value="1" step="0.5">
                </div>
            </div>

            <!-- Inputs for Circle -->
            <div id="circleInputs" class="hidden">
                <label>Radius (Units)</label>
                <input type="number" id="itemRadius" value="1" step="0.5">
            </div>

            <label>Color</label>
            <input type="color" id="itemColor" value="#3b82f6" style="height: 40px; width: 100%;">

            <button id="addBtn">Spawn Item</button>
        </div>

        <!-- Selected Item Properties -->
        <div class="control-group">
            <h3>5. Properties</h3>
            <div class="row">
                <div>
                    <label>Rotation (Â°)</label>
                    <input type="number" id="itemRotationInput" value="0" step="15">
                </div>
            </div>
        </div>

        <!-- Item Management -->
        <div class="control-group">
            <h3>Selection</h3>
            <p style="font-size: 0.85rem; color: #666;">Click item to drag. Use pink handle to rotate. Drag white handles to resize. Delete key to remove.</p>
        </div>

        <button id="deleteBtn" class="delete-btn" disabled>Delete Selected</button>
    </aside>

    <!-- Main Workspace -->
    <main id="workspace">
        <div id="room" style="width: 600px; height: 400px;">
            <!-- Furniture items will be injected here -->
        </div>
    </main>

    <script>
        /* --- State & Elements --- */
        const room = document.getElementById('room');
        const workspace = document.getElementById('workspace');
        
        // Inputs
        const unitSizeInput = document.getElementById('unitSize');
        const roomWInput = document.getElementById('roomWidth');
        const roomHInput = document.getElementById('roomHeight');
        const roomUnitsDisplay = document.getElementById('roomUnitsDisplay');
        const snapEnabledInput = document.getElementById('snapEnabled');
        const snapStepInput = document.getElementById('snapStep');
        
        const shapeSelect = document.getElementById('itemShape');
        const rectInputs = document.getElementById('rectInputs');
        const circleInputs = document.getElementById('circleInputs');
        const itemWInput = document.getElementById('itemWidth');
        const itemHInput = document.getElementById('itemHeight');
        const itemRadiusInput = document.getElementById('itemRadius');
        const itemColorInput = document.getElementById('itemColor');
        
        const itemRotationInput = document.getElementById('itemRotationInput');
        
        const addBtn = document.getElementById('addBtn');
        const deleteBtn = document.getElementById('deleteBtn');

        let selectedItem = null;
        let isDragging = false;
        let isResizing = false;
        let isRotating = false;
        
        // State for dragging
        let dragOffsetX = 0;
        let dragOffsetY = 0;

        // State for resizing
        let resizeDirection = '';
        let initialResizeRect = {};
        let initialMousePos = {};
        let initialRotation = 0;

        // State for rotating
        let rotateCenter = {x:0, y:0};
        let initialAngle = 0;

        /* --- Initialization --- */
        function init() {
            updateGrid();
            updateRoomSize();
        }

        /* --- Unit / Grid Logic --- */
        function updateGrid() {
            const unit = parseInt(unitSizeInput.value) || 50;
            workspace.style.backgroundSize = `${unit}px ${unit}px`;
            updateRoomDisplayText();
        }

        unitSizeInput.addEventListener('input', updateGrid);

        /* --- Room Resizing Logic --- */
        function updateRoomSize() {
            let w = parseInt(roomWInput.value) || 600;
            let h = parseInt(roomHInput.value) || 400;
            
            if(w < 100) w = 100;
            if(h < 100) h = 100;

            room.style.width = w + 'px';
            room.style.height = h + 'px';
            
            updateRoomDisplayText();
            
            const items = document.querySelectorAll('.furniture');
            items.forEach(item => constrainItem(item));
        }

        function updateRoomDisplayText() {
            const w = parseInt(room.style.width);
            const h = parseInt(room.style.height);
            const unit = parseInt(unitSizeInput.value) || 50;
            
            const wUnits = (w / unit).toFixed(1);
            const hUnits = (h / unit).toFixed(1);
            
            roomUnitsDisplay.textContent = `Room is approx ${wUnits} x ${hUnits} units`;
        }

        roomWInput.addEventListener('input', updateRoomSize);
        roomHInput.addEventListener('input', updateRoomSize);

        /* --- UI Toggle for Inputs --- */
        shapeSelect.addEventListener('change', (e) => {
            if (e.target.value === 'rectangle') {
                rectInputs.classList.remove('hidden');
                circleInputs.classList.add('hidden');
            } else {
                rectInputs.classList.add('hidden');
                circleInputs.classList.remove('hidden');
            }
        });

        /* --- Snapping Helper --- */
        function snapValue(val) {
            if (!snapEnabledInput.checked) return val;
            
            const unit = parseInt(unitSizeInput.value) || 50;
            const stepUnits = parseFloat(snapStepInput.value) || 0.5;
            const snapPixels = unit * stepUnits;
            
            return Math.round(val / snapPixels) * snapPixels;
        }

        /* --- Helper: Get Rotation from Element --- */
        function getRotation(el) {
            return parseFloat(el.dataset.rotation) || 0;
        }

        function setRotation(el, deg) {
            el.dataset.rotation = deg;
            el.style.transform = `rotate(${deg}deg)`;
            if(el === selectedItem) {
                itemRotationInput.value = Math.round(deg % 360);
            }
        }

        /* --- Sidebar Rotation Input --- */
        itemRotationInput.addEventListener('change', () => {
            if (selectedItem) {
                setRotation(selectedItem, parseFloat(itemRotationInput.value));
            }
        });

        /* --- Spawn Logic --- */
        addBtn.addEventListener('click', () => {
            const shape = shapeSelect.value;
            const color = itemColorInput.value;
            const unitSize = parseInt(unitSizeInput.value) || 50;
            
            const el = document.createElement('div');
            el.classList.add('furniture');
            el.style.backgroundColor = color;
            el.dataset.rotation = 0; // Init rotation

            let wPixels, hPixels;

            if (shape === 'rectangle') {
                const wUnits = parseFloat(itemWInput.value) || 1;
                const hUnits = parseFloat(itemHInput.value) || 1;
                wPixels = wUnits * unitSize;
                hPixels = hUnits * unitSize;
                el.style.width = wPixels + 'px';
                el.style.height = hPixels + 'px';
                el.style.borderRadius = '4px';
            } else {
                const rUnits = parseFloat(itemRadiusInput.value) || 0.5;
                const dPixels = (rUnits * 2) * unitSize;
                wPixels = dPixels;
                hPixels = dPixels;
                el.style.width = wPixels + 'px';
                el.style.height = hPixels + 'px';
                el.style.borderRadius = '50%';
            }

            // 1. Resize Handles
            const directions = ['nw', 'n', 'ne', 'e', 'se', 's', 'sw', 'w'];
            directions.forEach(dir => {
                const handle = document.createElement('div');
                handle.className = `resize-handle handle-${dir}`;
                handle.dataset.dir = dir;
                handle.addEventListener('mousedown', onResizeStart);
                el.appendChild(handle);
            });

            // 2. Rotation Handle
            const rotHandle = document.createElement('div');
            rotHandle.className = 'rotate-handle';
            rotHandle.addEventListener('mousedown', onRotateStart);
            el.appendChild(rotHandle);

            // Spawn in center
            const roomW = parseInt(room.style.width);
            const roomH = parseInt(room.style.height);
            el.style.left = (roomW / 2 - wPixels / 2) + 'px';
            el.style.top = (roomH / 2 - hPixels / 2) + 'px';

            el.addEventListener('mousedown', onDragStart);
            
            room.appendChild(el);
            selectItem(el);
        });

        /* --- Selection Logic --- */
        function selectItem(item) {
            if (selectedItem) {
                selectedItem.classList.remove('selected');
            }
            selectedItem = item;
            if (selectedItem) {
                selectedItem.classList.add('selected');
                deleteBtn.disabled = false;
                itemRotationInput.value = Math.round(getRotation(selectedItem) % 360);
                itemRotationInput.disabled = false;
            } else {
                deleteBtn.disabled = true;
                itemRotationInput.value = 0;
                itemRotationInput.disabled = true;
            }
        }

        room.addEventListener('mousedown', (e) => {
            if (e.target === room) {
                selectItem(null);
            }
        });

        /* --- Deletion Logic --- */
        function deleteSelected() {
            if (selectedItem) {
                selectedItem.remove();
                selectItem(null);
            }
        }

        deleteBtn.addEventListener('click', deleteSelected);

        window.addEventListener('keydown', (e) => {
            if (e.key === 'Delete' || e.key === 'Backspace') {
                if (document.activeElement.tagName === 'INPUT') return;
                deleteSelected();
            }
        });

        /* --- Dragging Logic --- */
        function onDragStart(e) {
            // Ignore if clicked on a handle
            if (e.target.classList.contains('resize-handle') || e.target.classList.contains('rotate-handle')) return;

            e.stopPropagation();
            const target = e.currentTarget;
            selectItem(target);

            isDragging = true;
            
            const rect = target.getBoundingClientRect();
            // Offset logic needs to be robust for rotated elements. 
            // We track the distance from mouse to the element's CSS `left/top` anchor.
            // Since we are moving `left` and `top`, we need to find the offset in the parent's coordinate space.
            const roomRect = room.getBoundingClientRect();
            
            // Current css left/top
            const cssLeft = parseFloat(target.style.left) || 0;
            const cssTop = parseFloat(target.style.top) || 0;
            
            // Mouse pos relative to room
            const mouseX = e.clientX - roomRect.left;
            const mouseY = e.clientY - roomRect.top;
            
            dragOffsetX = mouseX - cssLeft;
            dragOffsetY = mouseY - cssTop;

            window.addEventListener('mousemove', onDragMove);
            window.addEventListener('mouseup', onDragEnd);
        }

        function onDragMove(e) {
            if (!isDragging || !selectedItem) return;

            const roomRect = room.getBoundingClientRect();
            const mouseX = e.clientX - roomRect.left;
            const mouseY = e.clientY - roomRect.top;
            
            let newLeft = mouseX - dragOffsetX;
            let newTop = mouseY - dragOffsetY;

            // Apply Snap
            newLeft = snapValue(newLeft);
            newTop = snapValue(newTop);

            // Constraint (using unrotated box for simplicity and stability)
            const constrained = getConstrainedPosition(selectedItem, newLeft, newTop);

            selectedItem.style.left = constrained.x + 'px';
            selectedItem.style.top = constrained.y + 'px';
        }

        function onDragEnd() {
            isDragging = false;
            window.removeEventListener('mousemove', onDragMove);
            window.removeEventListener('mouseup', onDragEnd);
        }

        /* --- Rotation Logic --- */
        function onRotateStart(e) {
            e.stopPropagation();
            isRotating = true;
            
            const rect = selectedItem.getBoundingClientRect();
            // Center of the element in screen coordinates
            rotateCenter = {
                x: rect.left + rect.width / 2,
                y: rect.top + rect.height / 2
            };
            
            const dx = e.clientX - rotateCenter.x;
            const dy = e.clientY - rotateCenter.y;
            
            // Atan2 returns angle in radians from -PI to PI
            // We convert to degrees. 0 is Right (East). -90 is Up.
            initialAngle = Math.atan2(dy, dx) * (180 / Math.PI);
            initialRotation = getRotation(selectedItem);

            window.addEventListener('mousemove', onRotateMove);
            window.addEventListener('mouseup', onRotateEnd);
        }

        function onRotateMove(e) {
            if (!isRotating || !selectedItem) return;

            const dx = e.clientX - rotateCenter.x;
            const dy = e.clientY - rotateCenter.y;
            const currentAngle = Math.atan2(dy, dx) * (180 / Math.PI);
            
            let delta = currentAngle - initialAngle;
            let newRot = initialRotation + delta;

            // Optional Snap for rotation
            if (snapEnabledInput.checked) {
                // Snap to 15 degrees
                newRot = Math.round(newRot / 15) * 15;
            }

            setRotation(selectedItem, newRot);
        }

        function onRotateEnd() {
            isRotating = false;
            window.removeEventListener('mousemove', onRotateMove);
            window.removeEventListener('mouseup', onRotateEnd);
        }

        /* --- Resize Logic --- */
        function onResizeStart(e) {
            e.stopPropagation();
            isResizing = true;
            resizeDirection = e.target.dataset.dir;
            initialRotation = getRotation(selectedItem);
            
            // Store initial state
            const rect = selectedItem.getBoundingClientRect(); // Visual rect
            
            // We need the CSS width/height/left/top, not the visual rect
            initialResizeRect = {
                width: parseFloat(selectedItem.style.width),
                height: parseFloat(selectedItem.style.height),
                left: parseFloat(selectedItem.style.left),
                top: parseFloat(selectedItem.style.top)
            };

            initialMousePos = { x: e.clientX, y: e.clientY };

            window.addEventListener('mousemove', onResizeMove);
            window.addEventListener('mouseup', onResizeEnd);
        }

        function onResizeMove(e) {
            if (!isResizing || !selectedItem) return;

            // Raw mouse delta
            const rawDx = e.clientX - initialMousePos.x;
            const rawDy = e.clientY - initialMousePos.y;

            // Convert to Local Space based on rotation
            const rad = initialRotation * (Math.PI / 180);
            const cos = Math.cos(rad);
            const sin = Math.sin(rad);

            // Rotate vector (dx, dy) by -angle to get local axis aligned changes
            const localDx = rawDx * cos + rawDy * sin;
            const localDy = rawDy * cos - rawDx * sin;

            let newW = initialResizeRect.width;
            let newH = initialResizeRect.height;
            
            // We will NOT update left/top for N/W resizing to keep it stable with rotation.
            // This means N/W resizing will "push" the opposite side instead of "pulling" the edge.
            // Implementing correct anchor-point rotation resizing is complex for this scope.
            // We will allow width/height changes based on local axes.

            if (resizeDirection.includes('e')) newW += localDx;
            if (resizeDirection.includes('w')) newW -= localDx;
            if (resizeDirection.includes('s')) newH += localDy;
            if (resizeDirection.includes('n')) newH -= localDy;

            // Apply Snap to size (not position)
            newW = snapValue(newW);
            newH = snapValue(newH);

            if (newW < 20) newW = 20;
            if (newH < 20) newH = 20;

            selectedItem.style.width = newW + 'px';
            selectedItem.style.height = newH + 'px';
        }

        function onResizeEnd() {
            isResizing = false;
            window.removeEventListener('mousemove', onResizeMove);
            window.removeEventListener('mouseup', onResizeEnd);
        }

        /* --- Boundary Constraint Helper --- */
        function getConstrainedPosition(el, left, top) {
            const elW = parseFloat(el.style.width); // Use CSS width
            const elH = parseFloat(el.style.height);
            const roomW = parseInt(room.style.width);
            const roomH = parseInt(room.style.height);

            // Note: This strictly constraints the unrotated box.
            // Rotated corners might slightly exceed bounds visually.
            if (left < 0) left = 0;
            if (top < 0) top = 0;
            if (left + elW > roomW) left = roomW - elW;
            if (top + elH > roomH) top = roomH - elH;

            return { x: left, y: top };
        }

        function constrainItem(el) {
            const currentLeft = parseFloat(el.style.left) || 0;
            const currentTop = parseFloat(el.style.top) || 0;
            const pos = getConstrainedPosition(el, currentLeft, currentTop);
            el.style.left = pos.x + 'px';
            el.style.top = pos.y + 'px';
        }

        // Initialize on load
        init();

    </script>
</body>
</html>
